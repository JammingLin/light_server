// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package thrifttest

import (
	"bytes"
	"fmt"
	"thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type ThriftTest interface {
	// Prints "testVoid()" and returns nothing.
	TestVoid() (err error)
	// Prints 'testString("%s")' with thing as '%s'
	// @param string thing - the string to print
	// @return string - returns the string 'thing'
	//
	// Parameters:
	//  - Thing
	TestString(thing string) (r string, err error)
	// Prints 'testByte("%d")' with thing as '%d'
	// @param byte thing - the byte to print
	// @return byte - returns the byte 'thing'
	//
	// Parameters:
	//  - Thing
	TestByte(thing int8) (r int8, err error)
	// Prints 'testI32("%d")' with thing as '%d'
	// @param i32 thing - the i32 to print
	// @return i32 - returns the i32 'thing'
	//
	// Parameters:
	//  - Thing
	TestI32(thing int32) (r int32, err error)
	// Prints 'testI64("%d")' with thing as '%d'
	// @param i64 thing - the i64 to print
	// @return i64 - returns the i64 'thing'
	//
	// Parameters:
	//  - Thing
	TestI64(thing int64) (r int64, err error)
	// Prints 'testDouble("%f")' with thing as '%f'
	// @param double thing - the double to print
	// @return double - returns the double 'thing'
	//
	// Parameters:
	//  - Thing
	TestDouble(thing float64) (r float64, err error)
	// Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma seperated values
	// @param Xtruct thing - the Xtruct to print
	// @return Xtruct - returns the Xtruct 'thing'
	//
	// Parameters:
	//  - Thing
	TestStruct(thing *Xtruct) (r *Xtruct, err error)
	// Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
	// @param Xtruct2 thing - the Xtruct2 to print
	// @return Xtruct2 - returns the Xtruct2 'thing'
	//
	// Parameters:
	//  - Thing
	TestNest(thing *Xtruct2) (r *Xtruct2, err error)
	// Prints 'testMap("{%s")' where thing has been formatted into a string of  'key => value' pairs
	//  seperated by commas and new lines
	// @param map<i32,i32> thing - the map<i32,i32> to print
	// @return map<i32,i32> - returns the map<i32,i32> 'thing'
	//
	// Parameters:
	//  - Thing
	TestMap(thing map[int32]int32) (r map[int32]int32, err error)
	// Prints 'testStringMap("{%s}")' where thing has been formatted into a string of  'key => value' pairs
	//  seperated by commas and new lines
	// @param map<string,string> thing - the map<string,string> to print
	// @return map<string,string> - returns the map<string,string> 'thing'
	//
	// Parameters:
	//  - Thing
	TestStringMap(thing map[string]string) (r map[string]string, err error)
	// Prints 'testSet("{%s}")' where thing has been formatted into a string of  values
	//  seperated by commas and new lines
	// @param set<i32> thing - the set<i32> to print
	// @return set<i32> - returns the set<i32> 'thing'
	//
	// Parameters:
	//  - Thing
	TestSet(thing map[int32]bool) (r map[int32]bool, err error)
	// Prints 'testList("{%s}")' where thing has been formatted into a string of  values
	//  seperated by commas and new lines
	// @param list<i32> thing - the list<i32> to print
	// @return list<i32> - returns the list<i32> 'thing'
	//
	// Parameters:
	//  - Thing
	TestList(thing []int32) (r []int32, err error)
	// Prints 'testEnum("%d")' where thing has been formatted into it's numeric value
	// @param Numberz thing - the Numberz to print
	// @return Numberz - returns the Numberz 'thing'
	//
	// Parameters:
	//  - Thing
	TestEnum(thing Numberz) (r Numberz, err error)
	// Prints 'testTypedef("%d")' with thing as '%d'
	// @param UserId thing - the UserId to print
	// @return UserId - returns the UserId 'thing'
	//
	// Parameters:
	//  - Thing
	TestTypedef(thing UserId) (r UserId, err error)
	// Prints 'testMapMap("%d")' with hello as '%d'
	// @param i32 hello - the i32 to print
	// @return map<i32,map<i32,i32>> - returns a dictionary with these values:
	//   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
	//
	// Parameters:
	//  - Hello
	TestMapMap(hello int32) (r map[int32]map[int32]int32, err error)
	// So you think you've got this all worked, out eh?
	//
	// Creates a the returned map with these values and prints it out:
	//   { 1 => { 2 => argument,
	//            3 => argument,
	//          },
	//     2 => { 6 => <empty Insanity struct>, },
	//   }
	// @return map<UserId, map<Numberz,Insanity>> - a map with the above values
	//
	// Parameters:
	//  - Argument
	TestInsanity(argument *Insanity) (r map[UserId]map[Numberz]*Insanity, err error)
	// Prints 'testMulti()'
	// @param byte arg0 -
	// @param i32 arg1 -
	// @param i64 arg2 -
	// @param map<i16, string> arg3 -
	// @param Numberz arg4 -
	// @param UserId arg5 -
	// @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
	//    and i64_thing = arg2
	//
	// Parameters:
	//  - Arg0
	//  - Arg1
	//  - Arg2
	//  - Arg3
	//  - Arg4
	//  - Arg5
	TestMulti(arg0 int8, arg1 int32, arg2 int64, arg3 map[int16]string, arg4 Numberz, arg5 UserId) (r *Xtruct, err error)
	// Print 'testException(%s)' with arg as '%s'
	// @param string arg - a string indication what type of exception to throw
	// if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
	// elsen if arg == "TException" throw TException
	// else do not throw anything
	//
	// Parameters:
	//  - Arg
	TestException(arg string) (err error)
	// Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
	// @param string arg - a string indication what type of exception to throw
	// if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
	// elsen if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and message = "This is an Xception2"
	// else do not throw anything
	// @return Xtruct - an Xtruct with string_thing = arg1
	//
	// Parameters:
	//  - Arg0
	//  - Arg1
	TestMultiException(arg0 string, arg1 string) (r *Xtruct, err error)
	// Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
	// sleep 'secondsToSleep'
	// Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
	// @param i32 secondsToSleep - the number of seconds to sleep
	//
	// Parameters:
	//  - SecondsToSleep
	TestOneway(secondsToSleep int32) (err error)
}

type ThriftTestClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewThriftTestClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ThriftTestClient {
	return &ThriftTestClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewThriftTestClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ThriftTestClient {
	return &ThriftTestClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Prints "testVoid()" and returns nothing.
func (p *ThriftTestClient) TestVoid() (err error) {
	if err = p.sendTestVoid(); err != nil {
		return
	}
	return p.recvTestVoid()
}

func (p *ThriftTestClient) sendTestVoid() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testVoid", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestVoidArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestVoid() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error32 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error33 error
		error33, err = error32.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error33
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testVoid failed: out of sequence response")
		return
	}
	result := TestVoidResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	return
}

// Prints 'testString("%s")' with thing as '%s'
// @param string thing - the string to print
// @return string - returns the string 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestString(thing string) (r string, err error) {
	if err = p.sendTestString(thing); err != nil {
		return
	}
	return p.recvTestString()
}

func (p *ThriftTestClient) sendTestString(thing string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testString", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestStringArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestString() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error34 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error35 error
		error35, err = error34.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error35
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testString failed: out of sequence response")
		return
	}
	result := TestStringResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testByte("%d")' with thing as '%d'
// @param byte thing - the byte to print
// @return byte - returns the byte 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestByte(thing int8) (r int8, err error) {
	if err = p.sendTestByte(thing); err != nil {
		return
	}
	return p.recvTestByte()
}

func (p *ThriftTestClient) sendTestByte(thing int8) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testByte", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestByteArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestByte() (value int8, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error36 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error37 error
		error37, err = error36.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error37
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testByte failed: out of sequence response")
		return
	}
	result := TestByteResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testI32("%d")' with thing as '%d'
// @param i32 thing - the i32 to print
// @return i32 - returns the i32 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestI32(thing int32) (r int32, err error) {
	if err = p.sendTestI32(thing); err != nil {
		return
	}
	return p.recvTestI32()
}

func (p *ThriftTestClient) sendTestI32(thing int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testI32", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestI32Args{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestI32() (value int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error38 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error39 error
		error39, err = error38.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error39
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testI32 failed: out of sequence response")
		return
	}
	result := TestI32Result{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testI64("%d")' with thing as '%d'
// @param i64 thing - the i64 to print
// @return i64 - returns the i64 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestI64(thing int64) (r int64, err error) {
	if err = p.sendTestI64(thing); err != nil {
		return
	}
	return p.recvTestI64()
}

func (p *ThriftTestClient) sendTestI64(thing int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testI64", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestI64Args{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestI64() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error40 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error41 error
		error41, err = error40.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error41
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testI64 failed: out of sequence response")
		return
	}
	result := TestI64Result{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testDouble("%f")' with thing as '%f'
// @param double thing - the double to print
// @return double - returns the double 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestDouble(thing float64) (r float64, err error) {
	if err = p.sendTestDouble(thing); err != nil {
		return
	}
	return p.recvTestDouble()
}

func (p *ThriftTestClient) sendTestDouble(thing float64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testDouble", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestDoubleArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestDouble() (value float64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error42 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error43 error
		error43, err = error42.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error43
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testDouble failed: out of sequence response")
		return
	}
	result := TestDoubleResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma seperated values
// @param Xtruct thing - the Xtruct to print
// @return Xtruct - returns the Xtruct 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestStruct(thing *Xtruct) (r *Xtruct, err error) {
	if err = p.sendTestStruct(thing); err != nil {
		return
	}
	return p.recvTestStruct()
}

func (p *ThriftTestClient) sendTestStruct(thing *Xtruct) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testStruct", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestStructArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestStruct() (value *Xtruct, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error44 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error45 error
		error45, err = error44.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error45
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testStruct failed: out of sequence response")
		return
	}
	result := TestStructResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
// @param Xtruct2 thing - the Xtruct2 to print
// @return Xtruct2 - returns the Xtruct2 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestNest(thing *Xtruct2) (r *Xtruct2, err error) {
	if err = p.sendTestNest(thing); err != nil {
		return
	}
	return p.recvTestNest()
}

func (p *ThriftTestClient) sendTestNest(thing *Xtruct2) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testNest", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestNestArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestNest() (value *Xtruct2, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error46 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error47 error
		error47, err = error46.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error47
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testNest failed: out of sequence response")
		return
	}
	result := TestNestResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testMap("{%s")' where thing has been formatted into a string of  'key => value' pairs
//  seperated by commas and new lines
// @param map<i32,i32> thing - the map<i32,i32> to print
// @return map<i32,i32> - returns the map<i32,i32> 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestMap(thing map[int32]int32) (r map[int32]int32, err error) {
	if err = p.sendTestMap(thing); err != nil {
		return
	}
	return p.recvTestMap()
}

func (p *ThriftTestClient) sendTestMap(thing map[int32]int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testMap", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestMapArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestMap() (value map[int32]int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error48 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error49 error
		error49, err = error48.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error49
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testMap failed: out of sequence response")
		return
	}
	result := TestMapResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testStringMap("{%s}")' where thing has been formatted into a string of  'key => value' pairs
//  seperated by commas and new lines
// @param map<string,string> thing - the map<string,string> to print
// @return map<string,string> - returns the map<string,string> 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestStringMap(thing map[string]string) (r map[string]string, err error) {
	if err = p.sendTestStringMap(thing); err != nil {
		return
	}
	return p.recvTestStringMap()
}

func (p *ThriftTestClient) sendTestStringMap(thing map[string]string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testStringMap", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestStringMapArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestStringMap() (value map[string]string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error50 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error51 error
		error51, err = error50.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error51
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testStringMap failed: out of sequence response")
		return
	}
	result := TestStringMapResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testSet("{%s}")' where thing has been formatted into a string of  values
//  seperated by commas and new lines
// @param set<i32> thing - the set<i32> to print
// @return set<i32> - returns the set<i32> 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestSet(thing map[int32]bool) (r map[int32]bool, err error) {
	if err = p.sendTestSet(thing); err != nil {
		return
	}
	return p.recvTestSet()
}

func (p *ThriftTestClient) sendTestSet(thing map[int32]bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testSet", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestSetArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestSet() (value map[int32]bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error52 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error53 error
		error53, err = error52.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error53
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testSet failed: out of sequence response")
		return
	}
	result := TestSetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testList("{%s}")' where thing has been formatted into a string of  values
//  seperated by commas and new lines
// @param list<i32> thing - the list<i32> to print
// @return list<i32> - returns the list<i32> 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestList(thing []int32) (r []int32, err error) {
	if err = p.sendTestList(thing); err != nil {
		return
	}
	return p.recvTestList()
}

func (p *ThriftTestClient) sendTestList(thing []int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testList", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestListArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestList() (value []int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error54 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error55 error
		error55, err = error54.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error55
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testList failed: out of sequence response")
		return
	}
	result := TestListResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testEnum("%d")' where thing has been formatted into it's numeric value
// @param Numberz thing - the Numberz to print
// @return Numberz - returns the Numberz 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestEnum(thing Numberz) (r Numberz, err error) {
	if err = p.sendTestEnum(thing); err != nil {
		return
	}
	return p.recvTestEnum()
}

func (p *ThriftTestClient) sendTestEnum(thing Numberz) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testEnum", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestEnumArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestEnum() (value Numberz, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error56 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error57 error
		error57, err = error56.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error57
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testEnum failed: out of sequence response")
		return
	}
	result := TestEnumResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testTypedef("%d")' with thing as '%d'
// @param UserId thing - the UserId to print
// @return UserId - returns the UserId 'thing'
//
// Parameters:
//  - Thing
func (p *ThriftTestClient) TestTypedef(thing UserId) (r UserId, err error) {
	if err = p.sendTestTypedef(thing); err != nil {
		return
	}
	return p.recvTestTypedef()
}

func (p *ThriftTestClient) sendTestTypedef(thing UserId) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testTypedef", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestTypedefArgs{
		Thing: thing,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestTypedef() (value UserId, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error58 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error59 error
		error59, err = error58.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error59
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testTypedef failed: out of sequence response")
		return
	}
	result := TestTypedefResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testMapMap("%d")' with hello as '%d'
// @param i32 hello - the i32 to print
// @return map<i32,map<i32,i32>> - returns a dictionary with these values:
//   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }
//
// Parameters:
//  - Hello
func (p *ThriftTestClient) TestMapMap(hello int32) (r map[int32]map[int32]int32, err error) {
	if err = p.sendTestMapMap(hello); err != nil {
		return
	}
	return p.recvTestMapMap()
}

func (p *ThriftTestClient) sendTestMapMap(hello int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testMapMap", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestMapMapArgs{
		Hello: hello,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestMapMap() (value map[int32]map[int32]int32, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error60 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error61 error
		error61, err = error60.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error61
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testMapMap failed: out of sequence response")
		return
	}
	result := TestMapMapResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// So you think you've got this all worked, out eh?
//
// Creates a the returned map with these values and prints it out:
//   { 1 => { 2 => argument,
//            3 => argument,
//          },
//     2 => { 6 => <empty Insanity struct>, },
//   }
// @return map<UserId, map<Numberz,Insanity>> - a map with the above values
//
// Parameters:
//  - Argument
func (p *ThriftTestClient) TestInsanity(argument *Insanity) (r map[UserId]map[Numberz]*Insanity, err error) {
	if err = p.sendTestInsanity(argument); err != nil {
		return
	}
	return p.recvTestInsanity()
}

func (p *ThriftTestClient) sendTestInsanity(argument *Insanity) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testInsanity", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestInsanityArgs{
		Argument: argument,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestInsanity() (value map[UserId]map[Numberz]*Insanity, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error62 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error63 error
		error63, err = error62.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error63
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testInsanity failed: out of sequence response")
		return
	}
	result := TestInsanityResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Prints 'testMulti()'
// @param byte arg0 -
// @param i32 arg1 -
// @param i64 arg2 -
// @param map<i16, string> arg3 -
// @param Numberz arg4 -
// @param UserId arg5 -
// @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
//    and i64_thing = arg2
//
// Parameters:
//  - Arg0
//  - Arg1
//  - Arg2
//  - Arg3
//  - Arg4
//  - Arg5
func (p *ThriftTestClient) TestMulti(arg0 int8, arg1 int32, arg2 int64, arg3 map[int16]string, arg4 Numberz, arg5 UserId) (r *Xtruct, err error) {
	if err = p.sendTestMulti(arg0, arg1, arg2, arg3, arg4, arg5); err != nil {
		return
	}
	return p.recvTestMulti()
}

func (p *ThriftTestClient) sendTestMulti(arg0 int8, arg1 int32, arg2 int64, arg3 map[int16]string, arg4 Numberz, arg5 UserId) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testMulti", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestMultiArgs{
		Arg0: arg0,
		Arg1: arg1,
		Arg2: arg2,
		Arg3: arg3,
		Arg4: arg4,
		Arg5: arg5,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestMulti() (value *Xtruct, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error64 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error65 error
		error65, err = error64.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error65
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testMulti failed: out of sequence response")
		return
	}
	result := TestMultiResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Print 'testException(%s)' with arg as '%s'
// @param string arg - a string indication what type of exception to throw
// if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
// elsen if arg == "TException" throw TException
// else do not throw anything
//
// Parameters:
//  - Arg
func (p *ThriftTestClient) TestException(arg string) (err error) {
	if err = p.sendTestException(arg); err != nil {
		return
	}
	return p.recvTestException()
}

func (p *ThriftTestClient) sendTestException(arg string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testException", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestExceptionArgs{
		Arg: arg,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestException() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error66 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error67 error
		error67, err = error66.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error67
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testException failed: out of sequence response")
		return
	}
	result := TestExceptionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err1 != nil {
		err = result.Err1
		return
	}
	return
}

// Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
// @param string arg - a string indication what type of exception to throw
// if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
// elsen if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and message = "This is an Xception2"
// else do not throw anything
// @return Xtruct - an Xtruct with string_thing = arg1
//
// Parameters:
//  - Arg0
//  - Arg1
func (p *ThriftTestClient) TestMultiException(arg0 string, arg1 string) (r *Xtruct, err error) {
	if err = p.sendTestMultiException(arg0, arg1); err != nil {
		return
	}
	return p.recvTestMultiException()
}

func (p *ThriftTestClient) sendTestMultiException(arg0 string, arg1 string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testMultiException", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := TestMultiExceptionArgs{
		Arg0: arg0,
		Arg1: arg1,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ThriftTestClient) recvTestMultiException() (value *Xtruct, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error68 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error69 error
		error69, err = error68.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error69
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "testMultiException failed: out of sequence response")
		return
	}
	result := TestMultiExceptionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err1 != nil {
		err = result.Err1
		return
	} else if result.Err2 != nil {
		err = result.Err2
		return
	}
	value = result.GetSuccess()
	return
}

// Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
// sleep 'secondsToSleep'
// Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
// @param i32 secondsToSleep - the number of seconds to sleep
//
// Parameters:
//  - SecondsToSleep
func (p *ThriftTestClient) TestOneway(secondsToSleep int32) (err error) {
	if err = p.sendTestOneway(secondsToSleep); err != nil {
		return
	}
	return
}

func (p *ThriftTestClient) sendTestOneway(secondsToSleep int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("testOneway", thrift.ONEWAY, p.SeqId); err != nil {
		return
	}
	args := TestOnewayArgs{
		SecondsToSleep: secondsToSleep,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

type ThriftTestProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ThriftTest
}

func (p *ThriftTestProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ThriftTestProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ThriftTestProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewThriftTestProcessor(handler ThriftTest) *ThriftTestProcessor {

	self70 := &ThriftTestProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self70.processorMap["testVoid"] = &thriftTestProcessorTestVoid{handler: handler}
	self70.processorMap["testString"] = &thriftTestProcessorTestString{handler: handler}
	self70.processorMap["testByte"] = &thriftTestProcessorTestByte{handler: handler}
	self70.processorMap["testI32"] = &thriftTestProcessorTestI32{handler: handler}
	self70.processorMap["testI64"] = &thriftTestProcessorTestI64{handler: handler}
	self70.processorMap["testDouble"] = &thriftTestProcessorTestDouble{handler: handler}
	self70.processorMap["testStruct"] = &thriftTestProcessorTestStruct{handler: handler}
	self70.processorMap["testNest"] = &thriftTestProcessorTestNest{handler: handler}
	self70.processorMap["testMap"] = &thriftTestProcessorTestMap{handler: handler}
	self70.processorMap["testStringMap"] = &thriftTestProcessorTestStringMap{handler: handler}
	self70.processorMap["testSet"] = &thriftTestProcessorTestSet{handler: handler}
	self70.processorMap["testList"] = &thriftTestProcessorTestList{handler: handler}
	self70.processorMap["testEnum"] = &thriftTestProcessorTestEnum{handler: handler}
	self70.processorMap["testTypedef"] = &thriftTestProcessorTestTypedef{handler: handler}
	self70.processorMap["testMapMap"] = &thriftTestProcessorTestMapMap{handler: handler}
	self70.processorMap["testInsanity"] = &thriftTestProcessorTestInsanity{handler: handler}
	self70.processorMap["testMulti"] = &thriftTestProcessorTestMulti{handler: handler}
	self70.processorMap["testException"] = &thriftTestProcessorTestException{handler: handler}
	self70.processorMap["testMultiException"] = &thriftTestProcessorTestMultiException{handler: handler}
	self70.processorMap["testOneway"] = &thriftTestProcessorTestOneway{handler: handler}
	return self70
}

func (p *ThriftTestProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x71 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x71.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x71

}

type thriftTestProcessorTestVoid struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestVoid) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestVoidArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testVoid", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestVoidResult{}
	var err2 error
	if err2 = p.handler.TestVoid(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testVoid: "+err2.Error())
		oprot.WriteMessageBegin("testVoid", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	if err2 = oprot.WriteMessageBegin("testVoid", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestString struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestString) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestStringArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testString", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestStringResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.TestString(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testString: "+err2.Error())
		oprot.WriteMessageBegin("testString", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testString", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestByte struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestByte) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestByteArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testByte", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestByteResult{}
	var retval int8
	var err2 error
	if retval, err2 = p.handler.TestByte(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testByte: "+err2.Error())
		oprot.WriteMessageBegin("testByte", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testByte", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestI32 struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestI32) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestI32Args{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testI32", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestI32Result{}
	var retval int32
	var err2 error
	if retval, err2 = p.handler.TestI32(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testI32: "+err2.Error())
		oprot.WriteMessageBegin("testI32", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testI32", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestI64 struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestI64) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestI64Args{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testI64", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestI64Result{}
	var retval int64
	var err2 error
	if retval, err2 = p.handler.TestI64(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testI64: "+err2.Error())
		oprot.WriteMessageBegin("testI64", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testI64", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestDouble struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestDouble) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestDoubleArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testDouble", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestDoubleResult{}
	var retval float64
	var err2 error
	if retval, err2 = p.handler.TestDouble(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testDouble: "+err2.Error())
		oprot.WriteMessageBegin("testDouble", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testDouble", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestStruct struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestStruct) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestStructArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testStruct", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestStructResult{}
	var retval *Xtruct
	var err2 error
	if retval, err2 = p.handler.TestStruct(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testStruct: "+err2.Error())
		oprot.WriteMessageBegin("testStruct", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testStruct", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestNest struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestNest) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestNestArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testNest", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestNestResult{}
	var retval *Xtruct2
	var err2 error
	if retval, err2 = p.handler.TestNest(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testNest: "+err2.Error())
		oprot.WriteMessageBegin("testNest", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testNest", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestMap struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestMapArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testMap", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestMapResult{}
	var retval map[int32]int32
	var err2 error
	if retval, err2 = p.handler.TestMap(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testMap: "+err2.Error())
		oprot.WriteMessageBegin("testMap", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testMap", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestStringMap struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestStringMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestStringMapArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testStringMap", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestStringMapResult{}
	var retval map[string]string
	var err2 error
	if retval, err2 = p.handler.TestStringMap(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testStringMap: "+err2.Error())
		oprot.WriteMessageBegin("testStringMap", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testStringMap", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestSet struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestSet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestSetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testSet", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestSetResult{}
	var retval map[int32]bool
	var err2 error
	if retval, err2 = p.handler.TestSet(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testSet: "+err2.Error())
		oprot.WriteMessageBegin("testSet", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testSet", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestList struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestList) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestListArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestListResult{}
	var retval []int32
	var err2 error
	if retval, err2 = p.handler.TestList(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testList: "+err2.Error())
		oprot.WriteMessageBegin("testList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testList", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestEnum struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestEnum) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestEnumArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testEnum", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestEnumResult{}
	var retval Numberz
	var err2 error
	if retval, err2 = p.handler.TestEnum(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testEnum: "+err2.Error())
		oprot.WriteMessageBegin("testEnum", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testEnum", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestTypedef struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestTypedef) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestTypedefArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testTypedef", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestTypedefResult{}
	var retval UserId
	var err2 error
	if retval, err2 = p.handler.TestTypedef(args.Thing); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testTypedef: "+err2.Error())
		oprot.WriteMessageBegin("testTypedef", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("testTypedef", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestMapMap struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestMapMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestMapMapArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testMapMap", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestMapMapResult{}
	var retval map[int32]map[int32]int32
	var err2 error
	if retval, err2 = p.handler.TestMapMap(args.Hello); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testMapMap: "+err2.Error())
		oprot.WriteMessageBegin("testMapMap", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testMapMap", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestInsanity struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestInsanity) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestInsanityArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testInsanity", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestInsanityResult{}
	var retval map[UserId]map[Numberz]*Insanity
	var err2 error
	if retval, err2 = p.handler.TestInsanity(args.Argument); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testInsanity: "+err2.Error())
		oprot.WriteMessageBegin("testInsanity", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testInsanity", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestMulti struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestMulti) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestMultiArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testMulti", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestMultiResult{}
	var retval *Xtruct
	var err2 error
	if retval, err2 = p.handler.TestMulti(args.Arg0, args.Arg1, args.Arg2, args.Arg3, args.Arg4, args.Arg5); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testMulti: "+err2.Error())
		oprot.WriteMessageBegin("testMulti", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testMulti", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestException struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestException) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestExceptionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testException", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestExceptionResult{}
	var err2 error
	if err2 = p.handler.TestException(args.Arg); err2 != nil {
		switch v := err2.(type) {
		case *Xception:
			result.Err1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testException: "+err2.Error())
			oprot.WriteMessageBegin("testException", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("testException", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestMultiException struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestMultiException) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestMultiExceptionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("testMultiException", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := TestMultiExceptionResult{}
	var retval *Xtruct
	var err2 error
	if retval, err2 = p.handler.TestMultiException(args.Arg0, args.Arg1); err2 != nil {
		switch v := err2.(type) {
		case *Xception:
			result.Err1 = v
		case *Xception2:
			result.Err2 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing testMultiException: "+err2.Error())
			oprot.WriteMessageBegin("testMultiException", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("testMultiException", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type thriftTestProcessorTestOneway struct {
	handler ThriftTest
}

func (p *thriftTestProcessorTestOneway) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := TestOnewayArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		return false, err
	}

	iprot.ReadMessageEnd()
	var err2 error
	if err2 = p.handler.TestOneway(args.SecondsToSleep); err2 != nil {
		return true, err2
	}
	return true, nil
}

// HELPER FUNCTIONS AND STRUCTURES

type TestVoidArgs struct {
}

func NewTestVoidArgs() *TestVoidArgs {
	return &TestVoidArgs{}
}

func (p *TestVoidArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestVoidArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testVoid_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestVoidArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestVoidArgs(%+v)", *p)
}

type TestVoidResult struct {
}

func NewTestVoidResult() *TestVoidResult {
	return &TestVoidResult{}
}

func (p *TestVoidResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestVoidResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testVoid_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestVoidResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestVoidResult(%+v)", *p)
}

type TestStringArgs struct {
	Thing string `thrift:"thing,1" json:"thing"`
}

func NewTestStringArgs() *TestStringArgs {
	return &TestStringArgs{}
}

func (p *TestStringArgs) GetThing() string {
	return p.Thing
}
func (p *TestStringArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestStringArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Thing = v
	}
	return nil
}

func (p *TestStringArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testString_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestStringArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestStringArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestStringArgs(%+v)", *p)
}

type TestStringResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewTestStringResult() *TestStringResult {
	return &TestStringResult{}
}

var TestStringResult_Success_DEFAULT string

func (p *TestStringResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return TestStringResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestStringResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestStringResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestStringResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *TestStringResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testString_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestStringResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestStringResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestStringResult(%+v)", *p)
}

type TestByteArgs struct {
	Thing int8 `thrift:"thing,1" json:"thing"`
}

func NewTestByteArgs() *TestByteArgs {
	return &TestByteArgs{}
}

func (p *TestByteArgs) GetThing() int8 {
	return p.Thing
}
func (p *TestByteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestByteArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := int8(v)
		p.Thing = temp
	}
	return nil
}

func (p *TestByteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testByte_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestByteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.BYTE, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteByte(byte(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestByteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestByteArgs(%+v)", *p)
}

type TestByteResult struct {
	Success *int8 `thrift:"success,0" json:"success"`
}

func NewTestByteResult() *TestByteResult {
	return &TestByteResult{}
}

var TestByteResult_Success_DEFAULT int8

func (p *TestByteResult) GetSuccess() int8 {
	if !p.IsSetSuccess() {
		return TestByteResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestByteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestByteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestByteResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := int8(v)
		p.Success = &temp
	}
	return nil
}

func (p *TestByteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testByte_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestByteResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BYTE, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteByte(byte(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestByteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestByteResult(%+v)", *p)
}

type TestI32Args struct {
	Thing int32 `thrift:"thing,1" json:"thing"`
}

func NewTestI32Args() *TestI32Args {
	return &TestI32Args{}
}

func (p *TestI32Args) GetThing() int32 {
	return p.Thing
}
func (p *TestI32Args) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestI32Args) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Thing = v
	}
	return nil
}

func (p *TestI32Args) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testI32_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestI32Args) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestI32Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestI32Args(%+v)", *p)
}

type TestI32Result struct {
	Success *int32 `thrift:"success,0" json:"success"`
}

func NewTestI32Result() *TestI32Result {
	return &TestI32Result{}
}

var TestI32Result_Success_DEFAULT int32

func (p *TestI32Result) GetSuccess() int32 {
	if !p.IsSetSuccess() {
		return TestI32Result_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestI32Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestI32Result) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestI32Result) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *TestI32Result) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testI32_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestI32Result) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestI32Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestI32Result(%+v)", *p)
}

type TestI64Args struct {
	Thing int64 `thrift:"thing,1" json:"thing"`
}

func NewTestI64Args() *TestI64Args {
	return &TestI64Args{}
}

func (p *TestI64Args) GetThing() int64 {
	return p.Thing
}
func (p *TestI64Args) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestI64Args) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Thing = v
	}
	return nil
}

func (p *TestI64Args) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testI64_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestI64Args) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestI64Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestI64Args(%+v)", *p)
}

type TestI64Result struct {
	Success *int64 `thrift:"success,0" json:"success"`
}

func NewTestI64Result() *TestI64Result {
	return &TestI64Result{}
}

var TestI64Result_Success_DEFAULT int64

func (p *TestI64Result) GetSuccess() int64 {
	if !p.IsSetSuccess() {
		return TestI64Result_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestI64Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestI64Result) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestI64Result) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *TestI64Result) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testI64_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestI64Result) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestI64Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestI64Result(%+v)", *p)
}

type TestDoubleArgs struct {
	Thing float64 `thrift:"thing,1" json:"thing"`
}

func NewTestDoubleArgs() *TestDoubleArgs {
	return &TestDoubleArgs{}
}

func (p *TestDoubleArgs) GetThing() float64 {
	return p.Thing
}
func (p *TestDoubleArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestDoubleArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Thing = v
	}
	return nil
}

func (p *TestDoubleArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testDouble_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestDoubleArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.DOUBLE, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteDouble(float64(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestDoubleArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestDoubleArgs(%+v)", *p)
}

type TestDoubleResult struct {
	Success *float64 `thrift:"success,0" json:"success"`
}

func NewTestDoubleResult() *TestDoubleResult {
	return &TestDoubleResult{}
}

var TestDoubleResult_Success_DEFAULT float64

func (p *TestDoubleResult) GetSuccess() float64 {
	if !p.IsSetSuccess() {
		return TestDoubleResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestDoubleResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestDoubleResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestDoubleResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *TestDoubleResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testDouble_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestDoubleResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.DOUBLE, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestDoubleResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestDoubleResult(%+v)", *p)
}

type TestStructArgs struct {
	Thing *Xtruct `thrift:"thing,1" json:"thing"`
}

func NewTestStructArgs() *TestStructArgs {
	return &TestStructArgs{}
}

var TestStructArgs_Thing_DEFAULT *Xtruct

func (p *TestStructArgs) GetThing() *Xtruct {
	if !p.IsSetThing() {
		return TestStructArgs_Thing_DEFAULT
	}
	return p.Thing
}
func (p *TestStructArgs) IsSetThing() bool {
	return p.Thing != nil
}

func (p *TestStructArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestStructArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Thing = &Xtruct{}
	if err := p.Thing.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Thing, err)
	}
	return nil
}

func (p *TestStructArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testStruct_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestStructArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := p.Thing.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Thing, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestStructArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestStructArgs(%+v)", *p)
}

type TestStructResult struct {
	Success *Xtruct `thrift:"success,0" json:"success"`
}

func NewTestStructResult() *TestStructResult {
	return &TestStructResult{}
}

var TestStructResult_Success_DEFAULT *Xtruct

func (p *TestStructResult) GetSuccess() *Xtruct {
	if !p.IsSetSuccess() {
		return TestStructResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestStructResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestStructResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestStructResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Xtruct{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *TestStructResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testStruct_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestStructResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestStructResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestStructResult(%+v)", *p)
}

type TestNestArgs struct {
	Thing *Xtruct2 `thrift:"thing,1" json:"thing"`
}

func NewTestNestArgs() *TestNestArgs {
	return &TestNestArgs{}
}

var TestNestArgs_Thing_DEFAULT *Xtruct2

func (p *TestNestArgs) GetThing() *Xtruct2 {
	if !p.IsSetThing() {
		return TestNestArgs_Thing_DEFAULT
	}
	return p.Thing
}
func (p *TestNestArgs) IsSetThing() bool {
	return p.Thing != nil
}

func (p *TestNestArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestNestArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Thing = &Xtruct2{}
	if err := p.Thing.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Thing, err)
	}
	return nil
}

func (p *TestNestArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testNest_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestNestArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := p.Thing.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Thing, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestNestArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestNestArgs(%+v)", *p)
}

type TestNestResult struct {
	Success *Xtruct2 `thrift:"success,0" json:"success"`
}

func NewTestNestResult() *TestNestResult {
	return &TestNestResult{}
}

var TestNestResult_Success_DEFAULT *Xtruct2

func (p *TestNestResult) GetSuccess() *Xtruct2 {
	if !p.IsSetSuccess() {
		return TestNestResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestNestResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestNestResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestNestResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Xtruct2{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *TestNestResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testNest_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestNestResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestNestResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestNestResult(%+v)", *p)
}

type TestMapArgs struct {
	Thing map[int32]int32 `thrift:"thing,1" json:"thing"`
}

func NewTestMapArgs() *TestMapArgs {
	return &TestMapArgs{}
}

func (p *TestMapArgs) GetThing() map[int32]int32 {
	return p.Thing
}
func (p *TestMapArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMapArgs) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[int32]int32, size)
	p.Thing = tMap
	for i := 0; i < size; i++ {
		var _key72 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key72 = v
		}
		var _val73 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val73 = v
		}
		p.Thing[_key72] = _val73
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestMapArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMap_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMapArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.MAP, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(p.Thing)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Thing {
		if err := oprot.WriteI32(int32(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMapArgs(%+v)", *p)
}

type TestMapResult struct {
	Success map[int32]int32 `thrift:"success,0" json:"success"`
}

func NewTestMapResult() *TestMapResult {
	return &TestMapResult{}
}

var TestMapResult_Success_DEFAULT map[int32]int32

func (p *TestMapResult) GetSuccess() map[int32]int32 {
	return p.Success
}
func (p *TestMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestMapResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMapResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[int32]int32, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key74 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key74 = v
		}
		var _val75 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val75 = v
		}
		p.Success[_key74] = _val75
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestMapResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMap_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMapResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteI32(int32(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteI32(int32(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMapResult(%+v)", *p)
}

type TestStringMapArgs struct {
	Thing map[string]string `thrift:"thing,1" json:"thing"`
}

func NewTestStringMapArgs() *TestStringMapArgs {
	return &TestStringMapArgs{}
}

func (p *TestStringMapArgs) GetThing() map[string]string {
	return p.Thing
}
func (p *TestStringMapArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestStringMapArgs) ReadField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Thing = tMap
	for i := 0; i < size; i++ {
		var _key76 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key76 = v
		}
		var _val77 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val77 = v
		}
		p.Thing[_key76] = _val77
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestStringMapArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testStringMap_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestStringMapArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.MAP, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Thing)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Thing {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteString(string(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestStringMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestStringMapArgs(%+v)", *p)
}

type TestStringMapResult struct {
	Success map[string]string `thrift:"success,0" json:"success"`
}

func NewTestStringMapResult() *TestStringMapResult {
	return &TestStringMapResult{}
}

var TestStringMapResult_Success_DEFAULT map[string]string

func (p *TestStringMapResult) GetSuccess() map[string]string {
	return p.Success
}
func (p *TestStringMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestStringMapResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestStringMapResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]string, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key78 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key78 = v
		}
		var _val79 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val79 = v
		}
		p.Success[_key78] = _val79
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestStringMapResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testStringMap_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestStringMapResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestStringMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestStringMapResult(%+v)", *p)
}

type TestSetArgs struct {
	Thing map[int32]bool `thrift:"thing,1" json:"thing"`
}

func NewTestSetArgs() *TestSetArgs {
	return &TestSetArgs{}
}

func (p *TestSetArgs) GetThing() map[int32]bool {
	return p.Thing
}
func (p *TestSetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestSetArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[int32]bool, size)
	p.Thing = tSet
	for i := 0; i < size; i++ {
		var _elem80 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem80 = v
		}
		p.Thing[_elem80] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *TestSetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testSet_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestSetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.SET, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteSetBegin(thrift.I32, len(p.Thing)); err != nil {
		return fmt.Errorf("error writing set begin: %s", err)
	}
	for v, _ := range p.Thing {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteSetEnd(); err != nil {
		return fmt.Errorf("error writing set end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestSetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestSetArgs(%+v)", *p)
}

type TestSetResult struct {
	Success map[int32]bool `thrift:"success,0" json:"success"`
}

func NewTestSetResult() *TestSetResult {
	return &TestSetResult{}
}

var TestSetResult_Success_DEFAULT map[int32]bool

func (p *TestSetResult) GetSuccess() map[int32]bool {
	return p.Success
}
func (p *TestSetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestSetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestSetResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadSetBegin()
	if err != nil {
		return fmt.Errorf("error reading set begin: %s", err)
	}
	tSet := make(map[int32]bool, size)
	p.Success = tSet
	for i := 0; i < size; i++ {
		var _elem81 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem81 = v
		}
		p.Success[_elem81] = true
	}
	if err := iprot.ReadSetEnd(); err != nil {
		return fmt.Errorf("error reading set end: %s", err)
	}
	return nil
}

func (p *TestSetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testSet_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestSetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.SET, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteSetBegin(thrift.I32, len(p.Success)); err != nil {
			return fmt.Errorf("error writing set begin: %s", err)
		}
		for v, _ := range p.Success {
			if err := oprot.WriteI32(int32(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteSetEnd(); err != nil {
			return fmt.Errorf("error writing set end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestSetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestSetResult(%+v)", *p)
}

type TestListArgs struct {
	Thing []int32 `thrift:"thing,1" json:"thing"`
}

func NewTestListArgs() *TestListArgs {
	return &TestListArgs{}
}

func (p *TestListArgs) GetThing() []int32 {
	return p.Thing
}
func (p *TestListArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestListArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int32, 0, size)
	p.Thing = tSlice
	for i := 0; i < size; i++ {
		var _elem82 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem82 = v
		}
		p.Thing = append(p.Thing, _elem82)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *TestListArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testList_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestListArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.I32, len(p.Thing)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Thing {
		if err := oprot.WriteI32(int32(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestListArgs(%+v)", *p)
}

type TestListResult struct {
	Success []int32 `thrift:"success,0" json:"success"`
}

func NewTestListResult() *TestListResult {
	return &TestListResult{}
}

var TestListResult_Success_DEFAULT []int32

func (p *TestListResult) GetSuccess() []int32 {
	return p.Success
}
func (p *TestListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestListResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestListResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]int32, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem83 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_elem83 = v
		}
		p.Success = append(p.Success, _elem83)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *TestListResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testList_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestListResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.I32, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteI32(int32(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestListResult(%+v)", *p)
}

type TestEnumArgs struct {
	Thing Numberz `thrift:"thing,1" json:"thing"`
}

func NewTestEnumArgs() *TestEnumArgs {
	return &TestEnumArgs{}
}

func (p *TestEnumArgs) GetThing() Numberz {
	return p.Thing
}
func (p *TestEnumArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestEnumArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Numberz(v)
		p.Thing = temp
	}
	return nil
}

func (p *TestEnumArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testEnum_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestEnumArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestEnumArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestEnumArgs(%+v)", *p)
}

type TestEnumResult struct {
	Success *Numberz `thrift:"success,0" json:"success"`
}

func NewTestEnumResult() *TestEnumResult {
	return &TestEnumResult{}
}

var TestEnumResult_Success_DEFAULT Numberz

func (p *TestEnumResult) GetSuccess() Numberz {
	if !p.IsSetSuccess() {
		return TestEnumResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestEnumResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestEnumResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestEnumResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := Numberz(v)
		p.Success = &temp
	}
	return nil
}

func (p *TestEnumResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testEnum_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestEnumResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestEnumResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestEnumResult(%+v)", *p)
}

type TestTypedefArgs struct {
	Thing UserId `thrift:"thing,1" json:"thing"`
}

func NewTestTypedefArgs() *TestTypedefArgs {
	return &TestTypedefArgs{}
}

func (p *TestTypedefArgs) GetThing() UserId {
	return p.Thing
}
func (p *TestTypedefArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestTypedefArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := UserId(v)
		p.Thing = temp
	}
	return nil
}

func (p *TestTypedefArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testTypedef_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestTypedefArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("thing", thrift.I64, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:thing: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Thing)); err != nil {
		return fmt.Errorf("%T.thing (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:thing: %s", p, err)
	}
	return err
}

func (p *TestTypedefArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestTypedefArgs(%+v)", *p)
}

type TestTypedefResult struct {
	Success *UserId `thrift:"success,0" json:"success"`
}

func NewTestTypedefResult() *TestTypedefResult {
	return &TestTypedefResult{}
}

var TestTypedefResult_Success_DEFAULT UserId

func (p *TestTypedefResult) GetSuccess() UserId {
	if !p.IsSetSuccess() {
		return TestTypedefResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *TestTypedefResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestTypedefResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestTypedefResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := UserId(v)
		p.Success = &temp
	}
	return nil
}

func (p *TestTypedefResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testTypedef_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestTypedefResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestTypedefResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestTypedefResult(%+v)", *p)
}

type TestMapMapArgs struct {
	Hello int32 `thrift:"hello,1" json:"hello"`
}

func NewTestMapMapArgs() *TestMapMapArgs {
	return &TestMapMapArgs{}
}

func (p *TestMapMapArgs) GetHello() int32 {
	return p.Hello
}
func (p *TestMapMapArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMapMapArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Hello = v
	}
	return nil
}

func (p *TestMapMapArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMapMap_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMapMapArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("hello", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:hello: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Hello)); err != nil {
		return fmt.Errorf("%T.hello (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:hello: %s", p, err)
	}
	return err
}

func (p *TestMapMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMapMapArgs(%+v)", *p)
}

type TestMapMapResult struct {
	Success map[int32]map[int32]int32 `thrift:"success,0" json:"success"`
}

func NewTestMapMapResult() *TestMapMapResult {
	return &TestMapMapResult{}
}

var TestMapMapResult_Success_DEFAULT map[int32]map[int32]int32

func (p *TestMapMapResult) GetSuccess() map[int32]map[int32]int32 {
	return p.Success
}
func (p *TestMapMapResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestMapMapResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMapMapResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[int32]map[int32]int32, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key84 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key84 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s", err)
		}
		tMap := make(map[int32]int32, size)
		_val85 := tMap
		for i := 0; i < size; i++ {
			var _key86 int32
			if v, err := iprot.ReadI32(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_key86 = v
			}
			var _val87 int32
			if v, err := iprot.ReadI32(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				_val87 = v
			}
			_val85[_key86] = _val87
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s", err)
		}
		p.Success[_key84] = _val85
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestMapMapResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMapMap_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMapMapResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.I32, thrift.MAP, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteI32(int32(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.I32, thrift.I32, len(v)); err != nil {
				return fmt.Errorf("error writing map begin: %s", err)
			}
			for k, v := range v {
				if err := oprot.WriteI32(int32(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := oprot.WriteI32(int32(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestMapMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMapMapResult(%+v)", *p)
}

type TestInsanityArgs struct {
	Argument *Insanity `thrift:"argument,1" json:"argument"`
}

func NewTestInsanityArgs() *TestInsanityArgs {
	return &TestInsanityArgs{}
}

var TestInsanityArgs_Argument_DEFAULT *Insanity

func (p *TestInsanityArgs) GetArgument() *Insanity {
	if !p.IsSetArgument() {
		return TestInsanityArgs_Argument_DEFAULT
	}
	return p.Argument
}
func (p *TestInsanityArgs) IsSetArgument() bool {
	return p.Argument != nil
}

func (p *TestInsanityArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestInsanityArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Argument = &Insanity{}
	if err := p.Argument.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Argument, err)
	}
	return nil
}

func (p *TestInsanityArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testInsanity_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestInsanityArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("argument", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:argument: %s", p, err)
	}
	if err := p.Argument.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Argument, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:argument: %s", p, err)
	}
	return err
}

func (p *TestInsanityArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestInsanityArgs(%+v)", *p)
}

type TestInsanityResult struct {
	Success map[UserId]map[Numberz]*Insanity `thrift:"success,0" json:"success"`
}

func NewTestInsanityResult() *TestInsanityResult {
	return &TestInsanityResult{}
}

var TestInsanityResult_Success_DEFAULT map[UserId]map[Numberz]*Insanity

func (p *TestInsanityResult) GetSuccess() map[UserId]map[Numberz]*Insanity {
	return p.Success
}
func (p *TestInsanityResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestInsanityResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestInsanityResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[UserId]map[Numberz]*Insanity, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key88 UserId
		if v, err := iprot.ReadI64(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := UserId(v)
			_key88 = temp
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s", err)
		}
		tMap := make(map[Numberz]*Insanity, size)
		_val89 := tMap
		for i := 0; i < size; i++ {
			var _key90 Numberz
			if v, err := iprot.ReadI32(); err != nil {
				return fmt.Errorf("error reading field 0: %s", err)
			} else {
				temp := Numberz(v)
				_key90 = temp
			}
			_val91 := &Insanity{}
			if err := _val91.Read(iprot); err != nil {
				return fmt.Errorf("%T error reading struct: %s", _val91, err)
			}
			_val89[_key90] = _val91
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s", err)
		}
		p.Success[_key88] = _val89
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestInsanityResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testInsanity_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestInsanityResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.I64, thrift.MAP, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteI64(int64(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.I32, thrift.STRUCT, len(v)); err != nil {
				return fmt.Errorf("error writing map begin: %s", err)
			}
			for k, v := range v {
				if err := oprot.WriteI32(int32(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p, err)
				}
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v, err)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s", err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestInsanityResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestInsanityResult(%+v)", *p)
}

type TestMultiArgs struct {
	Arg0 int8             `thrift:"arg0,1" json:"arg0"`
	Arg1 int32            `thrift:"arg1,2" json:"arg1"`
	Arg2 int64            `thrift:"arg2,3" json:"arg2"`
	Arg3 map[int16]string `thrift:"arg3,4" json:"arg3"`
	Arg4 Numberz          `thrift:"arg4,5" json:"arg4"`
	Arg5 UserId           `thrift:"arg5,6" json:"arg5"`
}

func NewTestMultiArgs() *TestMultiArgs {
	return &TestMultiArgs{}
}

func (p *TestMultiArgs) GetArg0() int8 {
	return p.Arg0
}

func (p *TestMultiArgs) GetArg1() int32 {
	return p.Arg1
}

func (p *TestMultiArgs) GetArg2() int64 {
	return p.Arg2
}

func (p *TestMultiArgs) GetArg3() map[int16]string {
	return p.Arg3
}

func (p *TestMultiArgs) GetArg4() Numberz {
	return p.Arg4
}

func (p *TestMultiArgs) GetArg5() UserId {
	return p.Arg5
}
func (p *TestMultiArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMultiArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := int8(v)
		p.Arg0 = temp
	}
	return nil
}

func (p *TestMultiArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Arg1 = v
	}
	return nil
}

func (p *TestMultiArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Arg2 = v
	}
	return nil
}

func (p *TestMultiArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[int16]string, size)
	p.Arg3 = tMap
	for i := 0; i < size; i++ {
		var _key92 int16
		if v, err := iprot.ReadI16(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_key92 = v
		}
		var _val93 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			_val93 = v
		}
		p.Arg3[_key92] = _val93
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *TestMultiArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		temp := Numberz(v)
		p.Arg4 = temp
	}
	return nil
}

func (p *TestMultiArgs) ReadField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 6: %s", err)
	} else {
		temp := UserId(v)
		p.Arg5 = temp
	}
	return nil
}

func (p *TestMultiArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMulti_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMultiArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg0", thrift.BYTE, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:arg0: %s", p, err)
	}
	if err := oprot.WriteByte(byte(p.Arg0)); err != nil {
		return fmt.Errorf("%T.arg0 (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:arg0: %s", p, err)
	}
	return err
}

func (p *TestMultiArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg1", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:arg1: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Arg1)); err != nil {
		return fmt.Errorf("%T.arg1 (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:arg1: %s", p, err)
	}
	return err
}

func (p *TestMultiArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg2", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:arg2: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Arg2)); err != nil {
		return fmt.Errorf("%T.arg2 (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:arg2: %s", p, err)
	}
	return err
}

func (p *TestMultiArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg3", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:arg3: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.I16, thrift.STRING, len(p.Arg3)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Arg3 {
		if err := oprot.WriteI16(int16(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteString(string(v)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:arg3: %s", p, err)
	}
	return err
}

func (p *TestMultiArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg4", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:arg4: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Arg4)); err != nil {
		return fmt.Errorf("%T.arg4 (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:arg4: %s", p, err)
	}
	return err
}

func (p *TestMultiArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg5", thrift.I64, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:arg5: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Arg5)); err != nil {
		return fmt.Errorf("%T.arg5 (6) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:arg5: %s", p, err)
	}
	return err
}

func (p *TestMultiArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMultiArgs(%+v)", *p)
}

type TestMultiResult struct {
	Success *Xtruct `thrift:"success,0" json:"success"`
}

func NewTestMultiResult() *TestMultiResult {
	return &TestMultiResult{}
}

var TestMultiResult_Success_DEFAULT *Xtruct

func (p *TestMultiResult) GetSuccess() *Xtruct {
	if !p.IsSetSuccess() {
		return TestMultiResult_Success_DEFAULT
	}
	return p.Success
}
func (p *TestMultiResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestMultiResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMultiResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Xtruct{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *TestMultiResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMulti_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMultiResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestMultiResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMultiResult(%+v)", *p)
}

type TestExceptionArgs struct {
	Arg string `thrift:"arg,1" json:"arg"`
}

func NewTestExceptionArgs() *TestExceptionArgs {
	return &TestExceptionArgs{}
}

func (p *TestExceptionArgs) GetArg() string {
	return p.Arg
}
func (p *TestExceptionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestExceptionArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Arg = v
	}
	return nil
}

func (p *TestExceptionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testException_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestExceptionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:arg: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Arg)); err != nil {
		return fmt.Errorf("%T.arg (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:arg: %s", p, err)
	}
	return err
}

func (p *TestExceptionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestExceptionArgs(%+v)", *p)
}

type TestExceptionResult struct {
	Err1 *Xception `thrift:"err1,1" json:"err1"`
}

func NewTestExceptionResult() *TestExceptionResult {
	return &TestExceptionResult{}
}

var TestExceptionResult_Err1_DEFAULT *Xception

func (p *TestExceptionResult) GetErr1() *Xception {
	if !p.IsSetErr1() {
		return TestExceptionResult_Err1_DEFAULT
	}
	return p.Err1
}
func (p *TestExceptionResult) IsSetErr1() bool {
	return p.Err1 != nil
}

func (p *TestExceptionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestExceptionResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err1 = &Xception{}
	if err := p.Err1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Err1, err)
	}
	return nil
}

func (p *TestExceptionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testException_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestExceptionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr1() {
		if err := oprot.WriteFieldBegin("err1", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:err1: %s", p, err)
		}
		if err := p.Err1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Err1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:err1: %s", p, err)
		}
	}
	return err
}

func (p *TestExceptionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestExceptionResult(%+v)", *p)
}

type TestMultiExceptionArgs struct {
	Arg0 string `thrift:"arg0,1" json:"arg0"`
	Arg1 string `thrift:"arg1,2" json:"arg1"`
}

func NewTestMultiExceptionArgs() *TestMultiExceptionArgs {
	return &TestMultiExceptionArgs{}
}

func (p *TestMultiExceptionArgs) GetArg0() string {
	return p.Arg0
}

func (p *TestMultiExceptionArgs) GetArg1() string {
	return p.Arg1
}
func (p *TestMultiExceptionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMultiExceptionArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.Arg0 = v
	}
	return nil
}

func (p *TestMultiExceptionArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.Arg1 = v
	}
	return nil
}

func (p *TestMultiExceptionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMultiException_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMultiExceptionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg0", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:arg0: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Arg0)); err != nil {
		return fmt.Errorf("%T.arg0 (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:arg0: %s", p, err)
	}
	return err
}

func (p *TestMultiExceptionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("arg1", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:arg1: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Arg1)); err != nil {
		return fmt.Errorf("%T.arg1 (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:arg1: %s", p, err)
	}
	return err
}

func (p *TestMultiExceptionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMultiExceptionArgs(%+v)", *p)
}

type TestMultiExceptionResult struct {
	Success *Xtruct    `thrift:"success,0" json:"success"`
	Err1    *Xception  `thrift:"err1,1" json:"err1"`
	Err2    *Xception2 `thrift:"err2,2" json:"err2"`
}

func NewTestMultiExceptionResult() *TestMultiExceptionResult {
	return &TestMultiExceptionResult{}
}

var TestMultiExceptionResult_Success_DEFAULT *Xtruct

func (p *TestMultiExceptionResult) GetSuccess() *Xtruct {
	if !p.IsSetSuccess() {
		return TestMultiExceptionResult_Success_DEFAULT
	}
	return p.Success
}

var TestMultiExceptionResult_Err1_DEFAULT *Xception

func (p *TestMultiExceptionResult) GetErr1() *Xception {
	if !p.IsSetErr1() {
		return TestMultiExceptionResult_Err1_DEFAULT
	}
	return p.Err1
}

var TestMultiExceptionResult_Err2_DEFAULT *Xception2

func (p *TestMultiExceptionResult) GetErr2() *Xception2 {
	if !p.IsSetErr2() {
		return TestMultiExceptionResult_Err2_DEFAULT
	}
	return p.Err2
}
func (p *TestMultiExceptionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *TestMultiExceptionResult) IsSetErr1() bool {
	return p.Err1 != nil
}

func (p *TestMultiExceptionResult) IsSetErr2() bool {
	return p.Err2 != nil
}

func (p *TestMultiExceptionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestMultiExceptionResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Xtruct{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *TestMultiExceptionResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err1 = &Xception{}
	if err := p.Err1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Err1, err)
	}
	return nil
}

func (p *TestMultiExceptionResult) ReadField2(iprot thrift.TProtocol) error {
	p.Err2 = &Xception2{}
	if err := p.Err2.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Err2, err)
	}
	return nil
}

func (p *TestMultiExceptionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testMultiException_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestMultiExceptionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TestMultiExceptionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr1() {
		if err := oprot.WriteFieldBegin("err1", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:err1: %s", p, err)
		}
		if err := p.Err1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Err1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:err1: %s", p, err)
		}
	}
	return err
}

func (p *TestMultiExceptionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr2() {
		if err := oprot.WriteFieldBegin("err2", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:err2: %s", p, err)
		}
		if err := p.Err2.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Err2, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:err2: %s", p, err)
		}
	}
	return err
}

func (p *TestMultiExceptionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestMultiExceptionResult(%+v)", *p)
}

type TestOnewayArgs struct {
	SecondsToSleep int32 `thrift:"secondsToSleep,1" json:"secondsToSleep"`
}

func NewTestOnewayArgs() *TestOnewayArgs {
	return &TestOnewayArgs{}
}

func (p *TestOnewayArgs) GetSecondsToSleep() int32 {
	return p.SecondsToSleep
}
func (p *TestOnewayArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TestOnewayArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.SecondsToSleep = v
	}
	return nil
}

func (p *TestOnewayArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("testOneway_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *TestOnewayArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("secondsToSleep", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:secondsToSleep: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.SecondsToSleep)); err != nil {
		return fmt.Errorf("%T.secondsToSleep (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:secondsToSleep: %s", p, err)
	}
	return err
}

func (p *TestOnewayArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TestOnewayArgs(%+v)", *p)
}
